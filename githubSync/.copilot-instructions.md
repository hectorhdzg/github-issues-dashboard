# Copilot Instructions for GitHub Issues Dashboard

## Service Management Guidelines
- **NEVER KILL THE SERVICE**: Do not use taskkill, Stop-Process, or any commands that terminate the Python service
- **NEVER RESTART UNNECESSARILY**: Only restart if there are actual critical errors, not for minor code changes
- **USE CTRL+C GRACEFULLY**: If restart is absolutely required, use gentle termination methods
- **CHECK SERVICE STATUS FIRST**: Always verify if service is running before making changes
- **AVOID TERMINAL COMMAND SPAM**: Don't run multiple service start commands simultaneously

## Code Change Guidelines
- **HOT RELOAD**: Most code changes don't require service restart (Flask auto-reloads in debug mode)
- **DATABASE CHANGES**: Only restart for schema changes or database connection issues
- **CONFIGURATION CHANGES**: Only restart for major configuration or environment variable changes
- **UI CHANGES**: JavaScript/HTML/CSS changes are served immediately without restart
- **VERIFY BEFORE RESTART**: Always check if the change actually requires a restart

## Service Testing Guidelines
- **USE GENTLE TESTING**: Test API endpoints with curl or requests without killing service
- **CHECK LOGS FIRST**: Read service logs in terminal before assuming it needs restart
- **BACKGROUND VS FOREGROUND**: Use background mode for normal operation, foreground only for debugging
- **TERMINAL MANAGEMENT**: Don't spam multiple terminals with the same service
- **ERROR DIAGNOSIS**: Read actual error messages instead of immediately restarting

## File Management Guidelines
- **DO NOT CREATE NEW MARKDOWN FILES**: All documentation is consolidated in README.md
- Never create separate .md files for API docs, architecture, or any other documentation
- Update README.md directly if documentation changes are needed
- Clean up temporary files, backups, and unnecessary files immediately after use

## Testing Guidelines
- Always create temporary test files instead of running Python commands directly in terminal
- Use descriptive test file names with timestamp for uniqueness
- Automatically clean up test files after execution
- Test files should be self-contained and include error handling

## Code Patterns
- Use file-based testing for database queries and data analysis
- Include comprehensive error handling in all test scripts
- Always close database connections properly
- Use context managers where possible

## Repository Cleanup
- Remove backup files (*_backup.py, *_old.py) immediately after confirming they're not needed
- Delete temporary database files (*_backup_*.db, test_*.db) after use
- Clean up debug files (debug_*.py) once debugging is complete
- Maintain only essential files in the repository

## Debugging Workflow
1. Create test file with descriptive name
2. Run test file to gather information
3. Analyze results
4. Clean up test file automatically
5. Apply fixes to main code

## File Management
- Keep only essential files in the repository
- Remove temporary test files after use
- Maintain clean workspace structure

## Windows Environment Considerations
- Use proper PowerShell syntax for file operations
- Handle file paths with backslashes correctly
- Use appropriate Python execution methods for Windows

## Python Execution Guidelines
- **RUN PYTHON SCRIPTS DIRECTLY**: Never create batch files, PowerShell scripts, or wrapper scripts to start Python applications
- Use the proper Python executable path obtained from `get_python_executable_details` tool
- Run Python scripts directly in terminal using `run_in_terminal` with `isBackground=true` for services
- Example: Use `C:/Scripts/GitHub-Issues-Dashboard/.venv/Scripts/python.exe sync_service.py` directly
- **DO NOT CREATE**: start_sync.bat, start_app.ps1, or any wrapper scripts
- Clean up any existing wrapper scripts immediately

## External Program Execution
- **NEVER assume external programs are in PATH environment variable**
- Before running external programs (az, azd, docker, git, etc.), always check if they exist
- Use full paths when possible or check common installation locations
- Provide clear installation instructions if programs are missing
- Examples of programs that may not be in PATH:
  - Azure CLI (`az`)
  - Azure Developer CLI (`azd`)
  - Docker (`docker`)
  - Git (`git`)
  - Node.js/npm (`node`, `npm`)
- When programs fail with "not recognized" errors, guide user to install or add to PATH
- Consider using Windows-specific installation methods (winget, chocolatey, manual installers)
