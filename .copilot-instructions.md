# Copilot Instructions for GitHub Issues Dashboard

## Repository Structure
- **src/**: Main application files (app.py, sync_service.py, sync_manager.py)
- **scripts/**: Utility scripts (check_db.py, create_test_data.py, migrate_repositories.py)
- **data/**: Database files (github_issues.db)
- **templates/**: HTML templates
- **static/**: CSS, JS, and other static assets
- **tests/**: Test files
- **infra/**: Infrastructure as Code files
- **Root**: Only essential project files (README.md, requirements.txt, azure.yaml, .env, .gitignore)

## File Management Guidelines
- **DO NOT CREATE NEW MARKDOWN FILES**: All documentation is consolidated in README.md
- Never create separate .md files for API docs, architecture, or any other documentation
- Update README.md directly if documentation changes are needed
- Clean up temporary files, backups, and unnecessary files immediately after use

## Testing Guidelines
- Always create temporary test files instead of running Python commands directly in terminal
- Use descriptive test file names with timestamp for uniqueness
- Automatically clean up test files after execution
- Test files should be self-contained and include error handling

## Code Patterns
- Use file-based testing for database queries and data analysis
- Include comprehensive error handling in all test scripts
- Always close database connections properly
- Use context managers where possible

## Repository Cleanup
- Remove backup files (*_backup.py, *_old.py) immediately after confirming they're not needed
- Delete temporary database files (*_backup_*.db, test_*.db) after use
- Clean up debug files (debug_*.py) once debugging is complete
- Maintain only essential files in the repository

## Debugging Workflow
1. Create test file with descriptive name
2. Run test file to gather information
3. Analyze results
4. Clean up test file automatically
5. Apply fixes to main code

## File Management
- Keep only essential files in the repository
- Remove temporary test files after use
- Maintain clean workspace structure

## Windows Environment Considerations
- Use proper PowerShell syntax for file operations
- Handle file paths with backslashes correctly
- Use appropriate Python execution methods for Windows

## Python Execution Guidelines
- **RUN PYTHON SCRIPTS DIRECTLY**: Never create batch files, PowerShell scripts, or wrapper scripts to start Python applications
- Use the proper Python executable path obtained from `get_python_executable_details` tool
- Run Python scripts directly in terminal using `run_in_terminal` with `isBackground=true` for services
- Example: Use `C:/Scripts/GitHub-Issues-Dashboard/.venv/Scripts/python.exe sync_service.py` directly
- **DO NOT CREATE**: start_sync.bat, start_app.ps1, or any wrapper scripts
- Clean up any existing wrapper scripts immediately

## External Program Execution
- **NEVER assume external programs are in PATH environment variable**
- Before running external programs (az, azd, docker, git, etc.), always check if they exist
- Use full paths when possible or check common installation locations
- Provide clear installation instructions if programs are missing
- Examples of programs that may not be in PATH:
  - Azure CLI (`az`)
  - Azure Developer CLI (`azd`)
  - Docker (`docker`)
  - Git (`git`)
  - Node.js/npm (`node`, `npm`)
- When programs fail with "not recognized" errors, guide user to install or add to PATH
- Consider using Windows-specific installation methods (winget, chocolatey, manual installers)
